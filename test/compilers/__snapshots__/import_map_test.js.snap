export const snapshot = {};

snapshot[`import map > should map to bundle: prefix 1`] = `
'var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// node_modules/.pnpm/is-ip@5.0.0/node_modules/is-ip/index.js
import ipRegex from "/node_modules/.pnpm/ip-regex@5.0.0/node_modules/ip-regex/index.js";
import { isMatch } from "/node_modules/.pnpm/super-regex@0.2.0/node_modules/super-regex/index.js";
var maxIPv6Length = 45;
var options = {
  timeout: 400
};
function isIP(string) {
  return isMatch(ipRegex({ exact: true }), string.slice(0, maxIPv6Length), options);
}
__name(isIP, "isIP");

// lib/import_map/bare_modules.js
isIP();
//# sourceMappingURL=bare_modules.js.map
'
`;

snapshot[`import map > should map to bundle-all: prefix 1`] = `
'var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// bundleAll:/Users/joelmoss/dev/proscenium/test/internal/node_modules/.pnpm/ip-regex@5.0.0/node_modules/ip-regex/index.js
var word = "[a-fA-F\\\\\\\\d:]";
var boundry = /* @__PURE__ */ __name((options2) => options2 && options2.includeBoundaries ? \`(?:(?<=\\\\\\\\s|^)(?=\${word})|(?<=\${word})(?=\\\\\\\\s|\$))\` : "", "boundry");
var v4 = "(?:25[0-5]|2[0-4]\\\\\\\\d|1\\\\\\\\d\\\\\\\\d|[1-9]\\\\\\\\d|\\\\\\\\d)(?:\\\\\\\\.(?:25[0-5]|2[0-4]\\\\\\\\d|1\\\\\\\\d\\\\\\\\d|[1-9]\\\\\\\\d|\\\\\\\\d)){3}";
var v6segment = "[a-fA-F\\\\\\\\d]{1,4}";
var v6 = \`
(?:
(?:\${v6segment}:){7}(?:\${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:\${v6segment}:){6}(?:\${v4}|:\${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:\${v6segment}:){5}(?::\${v4}|(?::\${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:\${v6segment}:){4}(?:(?::\${v6segment}){0,1}:\${v4}|(?::\${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:\${v6segment}:){3}(?:(?::\${v6segment}){0,2}:\${v4}|(?::\${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:\${v6segment}:){2}(?:(?::\${v6segment}){0,3}:\${v4}|(?::\${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:\${v6segment}:){1}(?:(?::\${v6segment}){0,4}:\${v4}|(?::\${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::\${v6segment}){0,5}:\${v4}|(?::\${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
\`.replace(/\\\\s*\\\\/\\\\/.*\$/gm, "").replace(/\\
/g, "").trim();
var v46Exact = new RegExp(\`(?:^\${v4}\$)|(?:^\${v6}\$)\`);
var v4exact = new RegExp(\`^\${v4}\$\`);
var v6exact = new RegExp(\`^\${v6}\$\`);
var ipRegex = /* @__PURE__ */ __name((options2) => options2 && options2.exact ? v46Exact : new RegExp(\`(?:\${boundry(options2)}\${v4}\${boundry(options2)})|(?:\${boundry(options2)}\${v6}\${boundry(options2)})\`, "g"), "ipRegex");
ipRegex.v4 = (options2) => options2 && options2.exact ? v4exact : new RegExp(\`\${boundry(options2)}\${v4}\${boundry(options2)}\`, "g");
ipRegex.v6 = (options2) => options2 && options2.exact ? v6exact : new RegExp(\`\${boundry(options2)}\${v6}\${boundry(options2)}\`, "g");
var ip_regex_default = ipRegex;

// bundleAll:/Users/joelmoss/dev/proscenium/test/internal/node_modules/.pnpm/function-timeout@0.1.1/node_modules/function-timeout/browser.js
function functionTimeout(function_) {
  const wrappedFunction = /* @__PURE__ */ __name((...arguments_) => function_(...arguments_), "wrappedFunction");
  Object.defineProperty(wrappedFunction, "name", {
    value: \`functionTimeout(\${function_.name || "<anonymous>"})\`,
    configurable: true
  });
  return wrappedFunction;
}
__name(functionTimeout, "functionTimeout");
function isTimeoutError() {
  return false;
}
__name(isTimeoutError, "isTimeoutError");

// bundleAll:/Users/joelmoss/dev/proscenium/test/internal/node_modules/.pnpm/is-regexp@3.1.0/node_modules/is-regexp/index.js
var { toString } = Object.prototype;
function isRegexp(value) {
  return toString.call(value) === "[object RegExp]";
}
__name(isRegexp, "isRegexp");

// bundleAll:/Users/joelmoss/dev/proscenium/test/internal/node_modules/.pnpm/clone-regexp@3.0.0/node_modules/clone-regexp/index.js
var flagMap = {
  global: "g",
  ignoreCase: "i",
  multiline: "m",
  dotAll: "s",
  sticky: "y",
  unicode: "u"
};
function clonedRegexp(regexp, options2 = {}) {
  if (!isRegexp(regexp)) {
    throw new TypeError("Expected a RegExp instance");
  }
  const flags = Object.keys(flagMap).map((flag) => (typeof options2[flag] === "boolean" ? options2[flag] : regexp[flag]) ? flagMap[flag] : "").join("");
  const clonedRegexp2 = new RegExp(options2.source || regexp.source, flags);
  clonedRegexp2.lastIndex = typeof options2.lastIndex === "number" ? options2.lastIndex : regexp.lastIndex;
  return clonedRegexp2;
}
__name(clonedRegexp, "clonedRegexp");

// bundleAll:/Users/joelmoss/dev/proscenium/test/internal/node_modules/.pnpm/super-regex@0.2.0/node_modules/super-regex/index.js
function isMatch(regex, string, { timeout } = {}) {
  try {
    return functionTimeout(() => clonedRegexp(regex).test(string), { timeout })();
  } catch (error) {
    if (isTimeoutError(error)) {
      return false;
    }
    throw error;
  }
}
__name(isMatch, "isMatch");

// bundleAll:/Users/joelmoss/dev/proscenium/test/internal/node_modules/.pnpm/is-ip@5.0.0/node_modules/is-ip/index.js
var maxIPv6Length = 45;
var options = {
  timeout: 400
};
function isIP(string) {
  return isMatch(ip_regex_default({ exact: true }), string.slice(0, maxIPv6Length), options);
}
__name(isIP, "isIP");

// lib/import_map/bare_modules.js
isIP();
//# sourceMappingURL=bare_modules.js.map
'
`;

snapshot[`import map > should use root as resolveDir 1`] = `
"var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, \\"name\\", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === \\"object\\" || typeof from === \\"function\\") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. \\"__esModule\\" has not been set), then set
  // \\"default\\" to the CommonJS \\"module.exports\\" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \\"default\\", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, \\"__esModule\\", { value: true }), mod);

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js\\"(exports) {
    \\"use strict\\";
    if (true) {
      (function() {
        \\"use strict\\";
        var hasSymbol = typeof Symbol === \\"function\\" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\\"react.element\\") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\\"react.portal\\") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\\"react.fragment\\") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\\"react.strict_mode\\") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\\"react.profiler\\") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\\"react.provider\\") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\\"react.context\\") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\\"react.async_mode\\") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\\"react.concurrent_mode\\") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\\"react.forward_ref\\") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\\"react.suspense\\") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\\"react.suspense_list\\") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\\"react.memo\\") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\\"react.lazy\\") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\\"react.block\\") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\\"react.fundamental\\") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\\"react.responder\\") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\\"react.scope\\") : 60119;
        function isValidElementType(type) {
          return typeof type === \\"string\\" || typeof type === \\"function\\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \\"object\\" && type !== null && (type.\$\$typeof === REACT_LAZY_TYPE || type.\$\$typeof === REACT_MEMO_TYPE || type.\$\$typeof === REACT_PROVIDER_TYPE || type.\$\$typeof === REACT_CONTEXT_TYPE || type.\$\$typeof === REACT_FORWARD_REF_TYPE || type.\$\$typeof === REACT_FUNDAMENTAL_TYPE || type.\$\$typeof === REACT_RESPONDER_TYPE || type.\$\$typeof === REACT_SCOPE_TYPE || type.\$\$typeof === REACT_BLOCK_TYPE);
        }
        __name(isValidElementType, \\"isValidElementType\\");
        function typeOf(object) {
          if (typeof object === \\"object\\" && object !== null) {
            var \$\$typeof = object.\$\$typeof;
            switch (\$\$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var \$\$typeofType = type && type.\$\$typeof;
                    switch (\$\$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return \$\$typeofType;
                      default:
                        return \$\$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return \$\$typeof;
            }
          }
          return void 0;
        }
        __name(typeOf, \\"typeOf\\");
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console[\\"warn\\"](\\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\\");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        __name(isAsyncMode, \\"isAsyncMode\\");
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        __name(isConcurrentMode, \\"isConcurrentMode\\");
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        __name(isContextConsumer, \\"isContextConsumer\\");
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        __name(isContextProvider, \\"isContextProvider\\");
        function isElement(object) {
          return typeof object === \\"object\\" && object !== null && object.\$\$typeof === REACT_ELEMENT_TYPE;
        }
        __name(isElement, \\"isElement\\");
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        __name(isForwardRef, \\"isForwardRef\\");
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        __name(isFragment, \\"isFragment\\");
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        __name(isLazy, \\"isLazy\\");
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        __name(isMemo, \\"isMemo\\");
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        __name(isPortal, \\"isPortal\\");
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        __name(isProfiler, \\"isProfiler\\");
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        __name(isStrictMode, \\"isStrictMode\\");
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        __name(isSuspense, \\"isSuspense\\");
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js
var require_react_is = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js\\"(exports, module) {
    \\"use strict\\";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/src/object_assign.js
var object_assign_exports = {};
__export(object_assign_exports, {
  default: () => object_assign_default
});
var object_assign_default;
var init_object_assign = __esm({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/src/object_assign.js\\"() {
    object_assign_default = Object.assign;
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js\\"(exports, module) {
    \\"use strict\\";
    var ReactPropTypesSecret = \\"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\\";
    module.exports = ReactPropTypesSecret;
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js\\"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js\\"(exports, module) {
    \\"use strict\\";
    var printWarning = /* @__PURE__ */ __name(function() {
    }, \\"printWarning\\");
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = /* @__PURE__ */ __name(function(text) {
        var message = \\"Warning: \\" + text;
        if (typeof console !== \\"undefined\\") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      }, \\"printWarning\\");
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== \\"function\\") {
                var err = Error(
                  (componentName || \\"React class\\") + \\": \\" + location + \\" type \`\\" + typeSpecName + \\"\` is invalid; it must be a function, usually from the \`prop-types\` package, but received \`\\" + typeof typeSpecs[typeSpecName] + \\"\`.This often happens because of typos such as \`PropTypes.function\` instead of \`PropTypes.func\`.\\"
                );
                err.name = \\"Invariant Violation\\";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || \\"React class\\") + \\": type specification of \\" + location + \\" \`\\" + typeSpecName + \\"\` is invalid; the type checker function must return \`null\` or an \`Error\` but returned a \\" + typeof error + \\". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\\"
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : \\"\\";
              printWarning(
                \\"Failed \\" + location + \\" type: \\" + error.message + (stack != null ? stack : \\"\\")
              );
            }
          }
        }
      }
    }
    __name(checkPropTypes, \\"checkPropTypes\\");
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js\\"(exports, module) {
    \\"use strict\\";
    var ReactIs = require_react_is();
    var assign = (init_object_assign(), __toCommonJS(object_assign_exports));
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = /* @__PURE__ */ __name(function() {
    }, \\"printWarning\\");
    if (true) {
      printWarning = /* @__PURE__ */ __name(function(text) {
        var message = \\"Warning: \\" + text;
        if (typeof console !== \\"undefined\\") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      }, \\"printWarning\\");
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    __name(emptyFunctionThatReturnsNull, \\"emptyFunctionThatReturnsNull\\");
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === \\"function\\" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = \\"@@iterator\\";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === \\"function\\") {
          return iteratorFn;
        }
      }
      __name(getIteratorFn, \\"getIteratorFn\\");
      var ANONYMOUS = \\"<<anonymous>>\\";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker(\\"array\\"),
        bigint: createPrimitiveTypeChecker(\\"bigint\\"),
        bool: createPrimitiveTypeChecker(\\"boolean\\"),
        func: createPrimitiveTypeChecker(\\"function\\"),
        number: createPrimitiveTypeChecker(\\"number\\"),
        object: createPrimitiveTypeChecker(\\"object\\"),
        string: createPrimitiveTypeChecker(\\"string\\"),
        symbol: createPrimitiveTypeChecker(\\"symbol\\"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      __name(is, \\"is\\");
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === \\"object\\" ? data : {};
        this.stack = \\"\\";
      }
      __name(PropTypeError, \\"PropTypeError\\");
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                \\"Calling PropTypes validators directly is not supported by the \`prop-types\` package. Use \`PropTypes.checkPropTypes()\` to call them. Read more at http://fb.me/use-check-prop-types\\"
              );
              err.name = \\"Invariant Violation\\";
              throw err;
            } else if (typeof console !== \\"undefined\\") {
              var cacheKey = componentName + \\":\\" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  \\"You are manually calling a React.PropTypes validation function for the \`\\" + propFullName + \\"\` prop on \`\\" + componentName + \\"\`. This is deprecated and will throw in the standalone \`prop-types\` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\\"
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError(\\"The \\" + location + \\" \`\\" + propFullName + \\"\` is marked as required \\" + (\\"in \`\\" + componentName + \\"\`, but its value is \`null\`.\\"));
              }
              return new PropTypeError(\\"The \\" + location + \\" \`\\" + propFullName + \\"\` is marked as required in \\" + (\\"\`\\" + componentName + \\"\`, but its value is \`undefined\`.\\"));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        __name(checkType, \\"checkType\\");
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      __name(createChainableTypeChecker, \\"createChainableTypeChecker\\");
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              \\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + preciseType + \\"\` supplied to \`\\" + componentName + \\"\`, expected \\") + (\\"\`\\" + expectedType + \\"\`.\\"),
              { expectedType }
            );
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createPrimitiveTypeChecker, \\"createPrimitiveTypeChecker\\");
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      __name(createAnyTypeChecker, \\"createAnyTypeChecker\\");
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== \\"function\\") {
            return new PropTypeError(\\"Property \`\\" + propFullName + \\"\` of component \`\\" + componentName + \\"\` has invalid PropType notation inside arrayOf.\\");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected an array.\\"));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + \\"[\\" + i + \\"]\\", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createArrayOfTypeChecker, \\"createArrayOfTypeChecker\\");
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected a single ReactElement.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createElementTypeChecker, \\"createElementTypeChecker\\");
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected a single ReactElement type.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createElementTypeTypeChecker, \\"createElementTypeTypeChecker\\");
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + actualClassName + \\"\` supplied to \`\\" + componentName + \\"\`, expected \\") + (\\"instance of \`\\" + expectedClassName + \\"\`.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createInstanceTypeChecker, \\"createInstanceTypeChecker\\");
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                \\"Invalid arguments supplied to oneOf, expected an array, got \\" + arguments.length + \\" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\\"
              );
            } else {
              printWarning(\\"Invalid argument supplied to oneOf, expected an array.\\");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, /* @__PURE__ */ __name(function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === \\"symbol\\") {
              return String(value);
            }
            return value;
          }, \\"replacer\\"));
          return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of value \`\\" + String(propValue) + \\"\` \\" + (\\"supplied to \`\\" + componentName + \\"\`, expected one of \\" + valuesString + \\".\\"));
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createEnumTypeChecker, \\"createEnumTypeChecker\\");
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== \\"function\\") {
            return new PropTypeError(\\"Property \`\\" + propFullName + \\"\` of component \`\\" + componentName + \\"\` has invalid PropType notation inside objectOf.\\");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== \\"object\\") {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected an object.\\"));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + \\".\\" + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createObjectOfTypeChecker, \\"createObjectOfTypeChecker\\");
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning(\\"Invalid argument supplied to oneOfType, expected an instance of array.\\") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== \\"function\\") {
            printWarning(
              \\"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \\" + getPostfixForTypeWarning(checker) + \\" at index \\" + i + \\".\\"
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, \\"expectedType\\")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? \\", expected one of type [\\" + expectedTypes.join(\\", \\") + \\"]\\" : \\"\\";
          return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` supplied to \\" + (\\"\`\\" + componentName + \\"\`\\" + expectedTypesMessage + \\".\\"));
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createUnionTypeChecker, \\"createUnionTypeChecker\\");
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` supplied to \\" + (\\"\`\\" + componentName + \\"\`, expected a ReactNode.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createNodeChecker, \\"createNodeChecker\\");
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || \\"React class\\") + \\": \\" + location + \\" type \`\\" + propFullName + \\".\\" + key + \\"\` is invalid; it must be a function, usually from the \`prop-types\` package, but received \`\\" + type + \\"\`.\\"
        );
      }
      __name(invalidValidatorError, \\"invalidValidatorError\\");
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== \\"object\\") {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \`\\" + propType + \\"\` \\" + (\\"supplied to \`\\" + componentName + \\"\`, expected \`object\`.\\"));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== \\"function\\") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + \\".\\" + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createShapeTypeChecker, \\"createShapeTypeChecker\\");
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== \\"object\\") {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \`\\" + propType + \\"\` \\" + (\\"supplied to \`\\" + componentName + \\"\`, expected \`object\`.\\"));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== \\"function\\") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                \\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` key \`\\" + key + \\"\` supplied to \`\\" + componentName + \\"\`.\\
Bad object: \\" + JSON.stringify(props[propName], null, \\"  \\") + \\"\\
Valid keys: \\" + JSON.stringify(Object.keys(shapeTypes), null, \\"  \\")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + \\".\\" + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createStrictShapeTypeChecker, \\"createStrictShapeTypeChecker\\");
      function isNode(propValue) {
        switch (typeof propValue) {
          case \\"number\\":
          case \\"string\\":
          case \\"undefined\\":
            return true;
          case \\"boolean\\":
            return !propValue;
          case \\"object\\":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      __name(isNode, \\"isNode\\");
      function isSymbol(propType, propValue) {
        if (propType === \\"symbol\\") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue[\\"@@toStringTag\\"] === \\"Symbol\\") {
          return true;
        }
        if (typeof Symbol === \\"function\\" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      __name(isSymbol, \\"isSymbol\\");
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return \\"array\\";
        }
        if (propValue instanceof RegExp) {
          return \\"object\\";
        }
        if (isSymbol(propType, propValue)) {
          return \\"symbol\\";
        }
        return propType;
      }
      __name(getPropType, \\"getPropType\\");
      function getPreciseType(propValue) {
        if (typeof propValue === \\"undefined\\" || propValue === null) {
          return \\"\\" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === \\"object\\") {
          if (propValue instanceof Date) {
            return \\"date\\";
          } else if (propValue instanceof RegExp) {
            return \\"regexp\\";
          }
        }
        return propType;
      }
      __name(getPreciseType, \\"getPreciseType\\");
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case \\"array\\":
          case \\"object\\":
            return \\"an \\" + type;
          case \\"boolean\\":
          case \\"date\\":
          case \\"regexp\\":
            return \\"a \\" + type;
          default:
            return type;
        }
      }
      __name(getPostfixForTypeWarning, \\"getPostfixForTypeWarning\\");
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      __name(getClassName, \\"getClassName\\");
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js\\"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/src/prop_types.js
var import_bundle_all_prop_types = __toESM(require_prop_types());
var prop_types_default = /* @__PURE__ */ __name(() => {
  import_bundle_all_prop_types.default;
}, \\"default\\");

// lib/import_map/nested/index.js
console.log(prop_types_default);
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=index.js.map
"
`;

snapshot[`import map > should use root as resolveDir when using bundle: prefix 1`] = `
"var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, \\"name\\", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === \\"object\\" || typeof from === \\"function\\") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. \\"__esModule\\" has not been set), then set
  // \\"default\\" to the CommonJS \\"module.exports\\" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \\"default\\", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, \\"__esModule\\", { value: true }), mod);

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js\\"(exports) {
    \\"use strict\\";
    if (true) {
      (function() {
        \\"use strict\\";
        var hasSymbol = typeof Symbol === \\"function\\" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\\"react.element\\") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\\"react.portal\\") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\\"react.fragment\\") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\\"react.strict_mode\\") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\\"react.profiler\\") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\\"react.provider\\") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\\"react.context\\") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\\"react.async_mode\\") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\\"react.concurrent_mode\\") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\\"react.forward_ref\\") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\\"react.suspense\\") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\\"react.suspense_list\\") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\\"react.memo\\") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\\"react.lazy\\") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\\"react.block\\") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\\"react.fundamental\\") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\\"react.responder\\") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\\"react.scope\\") : 60119;
        function isValidElementType(type) {
          return typeof type === \\"string\\" || typeof type === \\"function\\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \\"object\\" && type !== null && (type.\$\$typeof === REACT_LAZY_TYPE || type.\$\$typeof === REACT_MEMO_TYPE || type.\$\$typeof === REACT_PROVIDER_TYPE || type.\$\$typeof === REACT_CONTEXT_TYPE || type.\$\$typeof === REACT_FORWARD_REF_TYPE || type.\$\$typeof === REACT_FUNDAMENTAL_TYPE || type.\$\$typeof === REACT_RESPONDER_TYPE || type.\$\$typeof === REACT_SCOPE_TYPE || type.\$\$typeof === REACT_BLOCK_TYPE);
        }
        __name(isValidElementType, \\"isValidElementType\\");
        function typeOf(object) {
          if (typeof object === \\"object\\" && object !== null) {
            var \$\$typeof = object.\$\$typeof;
            switch (\$\$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var \$\$typeofType = type && type.\$\$typeof;
                    switch (\$\$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return \$\$typeofType;
                      default:
                        return \$\$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return \$\$typeof;
            }
          }
          return void 0;
        }
        __name(typeOf, \\"typeOf\\");
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console[\\"warn\\"](\\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\\");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        __name(isAsyncMode, \\"isAsyncMode\\");
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        __name(isConcurrentMode, \\"isConcurrentMode\\");
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        __name(isContextConsumer, \\"isContextConsumer\\");
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        __name(isContextProvider, \\"isContextProvider\\");
        function isElement(object) {
          return typeof object === \\"object\\" && object !== null && object.\$\$typeof === REACT_ELEMENT_TYPE;
        }
        __name(isElement, \\"isElement\\");
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        __name(isForwardRef, \\"isForwardRef\\");
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        __name(isFragment, \\"isFragment\\");
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        __name(isLazy, \\"isLazy\\");
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        __name(isMemo, \\"isMemo\\");
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        __name(isPortal, \\"isPortal\\");
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        __name(isProfiler, \\"isProfiler\\");
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        __name(isStrictMode, \\"isStrictMode\\");
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        __name(isSuspense, \\"isSuspense\\");
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js
var require_react_is = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js\\"(exports, module) {
    \\"use strict\\";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// ../external/three/src/object_assign.js
var object_assign_exports = {};
__export(object_assign_exports, {
  default: () => object_assign_default
});
var object_assign_default;
var init_object_assign = __esm({
  \\"../external/three/src/object_assign.js\\"() {
    object_assign_default = Object.assign;
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js\\"(exports, module) {
    \\"use strict\\";
    var ReactPropTypesSecret = \\"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\\";
    module.exports = ReactPropTypesSecret;
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js\\"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js\\"(exports, module) {
    \\"use strict\\";
    var printWarning = /* @__PURE__ */ __name(function() {
    }, \\"printWarning\\");
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = /* @__PURE__ */ __name(function(text) {
        var message = \\"Warning: \\" + text;
        if (typeof console !== \\"undefined\\") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      }, \\"printWarning\\");
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== \\"function\\") {
                var err = Error(
                  (componentName || \\"React class\\") + \\": \\" + location + \\" type \`\\" + typeSpecName + \\"\` is invalid; it must be a function, usually from the \`prop-types\` package, but received \`\\" + typeof typeSpecs[typeSpecName] + \\"\`.This often happens because of typos such as \`PropTypes.function\` instead of \`PropTypes.func\`.\\"
                );
                err.name = \\"Invariant Violation\\";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || \\"React class\\") + \\": type specification of \\" + location + \\" \`\\" + typeSpecName + \\"\` is invalid; the type checker function must return \`null\` or an \`Error\` but returned a \\" + typeof error + \\". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\\"
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : \\"\\";
              printWarning(
                \\"Failed \\" + location + \\" type: \\" + error.message + (stack != null ? stack : \\"\\")
              );
            }
          }
        }
      }
    }
    __name(checkPropTypes, \\"checkPropTypes\\");
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js\\"(exports, module) {
    \\"use strict\\";
    var ReactIs = require_react_is();
    var assign = (init_object_assign(), __toCommonJS(object_assign_exports));
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = /* @__PURE__ */ __name(function() {
    }, \\"printWarning\\");
    if (true) {
      printWarning = /* @__PURE__ */ __name(function(text) {
        var message = \\"Warning: \\" + text;
        if (typeof console !== \\"undefined\\") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      }, \\"printWarning\\");
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    __name(emptyFunctionThatReturnsNull, \\"emptyFunctionThatReturnsNull\\");
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === \\"function\\" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = \\"@@iterator\\";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === \\"function\\") {
          return iteratorFn;
        }
      }
      __name(getIteratorFn, \\"getIteratorFn\\");
      var ANONYMOUS = \\"<<anonymous>>\\";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker(\\"array\\"),
        bigint: createPrimitiveTypeChecker(\\"bigint\\"),
        bool: createPrimitiveTypeChecker(\\"boolean\\"),
        func: createPrimitiveTypeChecker(\\"function\\"),
        number: createPrimitiveTypeChecker(\\"number\\"),
        object: createPrimitiveTypeChecker(\\"object\\"),
        string: createPrimitiveTypeChecker(\\"string\\"),
        symbol: createPrimitiveTypeChecker(\\"symbol\\"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      __name(is, \\"is\\");
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === \\"object\\" ? data : {};
        this.stack = \\"\\";
      }
      __name(PropTypeError, \\"PropTypeError\\");
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                \\"Calling PropTypes validators directly is not supported by the \`prop-types\` package. Use \`PropTypes.checkPropTypes()\` to call them. Read more at http://fb.me/use-check-prop-types\\"
              );
              err.name = \\"Invariant Violation\\";
              throw err;
            } else if (typeof console !== \\"undefined\\") {
              var cacheKey = componentName + \\":\\" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  \\"You are manually calling a React.PropTypes validation function for the \`\\" + propFullName + \\"\` prop on \`\\" + componentName + \\"\`. This is deprecated and will throw in the standalone \`prop-types\` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\\"
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError(\\"The \\" + location + \\" \`\\" + propFullName + \\"\` is marked as required \\" + (\\"in \`\\" + componentName + \\"\`, but its value is \`null\`.\\"));
              }
              return new PropTypeError(\\"The \\" + location + \\" \`\\" + propFullName + \\"\` is marked as required in \\" + (\\"\`\\" + componentName + \\"\`, but its value is \`undefined\`.\\"));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        __name(checkType, \\"checkType\\");
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      __name(createChainableTypeChecker, \\"createChainableTypeChecker\\");
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              \\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + preciseType + \\"\` supplied to \`\\" + componentName + \\"\`, expected \\") + (\\"\`\\" + expectedType + \\"\`.\\"),
              { expectedType }
            );
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createPrimitiveTypeChecker, \\"createPrimitiveTypeChecker\\");
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      __name(createAnyTypeChecker, \\"createAnyTypeChecker\\");
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== \\"function\\") {
            return new PropTypeError(\\"Property \`\\" + propFullName + \\"\` of component \`\\" + componentName + \\"\` has invalid PropType notation inside arrayOf.\\");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected an array.\\"));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + \\"[\\" + i + \\"]\\", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createArrayOfTypeChecker, \\"createArrayOfTypeChecker\\");
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected a single ReactElement.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createElementTypeChecker, \\"createElementTypeChecker\\");
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected a single ReactElement type.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createElementTypeTypeChecker, \\"createElementTypeTypeChecker\\");
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + actualClassName + \\"\` supplied to \`\\" + componentName + \\"\`, expected \\") + (\\"instance of \`\\" + expectedClassName + \\"\`.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createInstanceTypeChecker, \\"createInstanceTypeChecker\\");
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                \\"Invalid arguments supplied to oneOf, expected an array, got \\" + arguments.length + \\" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\\"
              );
            } else {
              printWarning(\\"Invalid argument supplied to oneOf, expected an array.\\");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, /* @__PURE__ */ __name(function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === \\"symbol\\") {
              return String(value);
            }
            return value;
          }, \\"replacer\\"));
          return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of value \`\\" + String(propValue) + \\"\` \\" + (\\"supplied to \`\\" + componentName + \\"\`, expected one of \\" + valuesString + \\".\\"));
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createEnumTypeChecker, \\"createEnumTypeChecker\\");
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== \\"function\\") {
            return new PropTypeError(\\"Property \`\\" + propFullName + \\"\` of component \`\\" + componentName + \\"\` has invalid PropType notation inside objectOf.\\");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== \\"object\\") {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected an object.\\"));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + \\".\\" + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createObjectOfTypeChecker, \\"createObjectOfTypeChecker\\");
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning(\\"Invalid argument supplied to oneOfType, expected an instance of array.\\") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== \\"function\\") {
            printWarning(
              \\"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \\" + getPostfixForTypeWarning(checker) + \\" at index \\" + i + \\".\\"
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, \\"expectedType\\")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? \\", expected one of type [\\" + expectedTypes.join(\\", \\") + \\"]\\" : \\"\\";
          return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` supplied to \\" + (\\"\`\\" + componentName + \\"\`\\" + expectedTypesMessage + \\".\\"));
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createUnionTypeChecker, \\"createUnionTypeChecker\\");
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` supplied to \\" + (\\"\`\\" + componentName + \\"\`, expected a ReactNode.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createNodeChecker, \\"createNodeChecker\\");
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || \\"React class\\") + \\": \\" + location + \\" type \`\\" + propFullName + \\".\\" + key + \\"\` is invalid; it must be a function, usually from the \`prop-types\` package, but received \`\\" + type + \\"\`.\\"
        );
      }
      __name(invalidValidatorError, \\"invalidValidatorError\\");
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== \\"object\\") {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \`\\" + propType + \\"\` \\" + (\\"supplied to \`\\" + componentName + \\"\`, expected \`object\`.\\"));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== \\"function\\") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + \\".\\" + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createShapeTypeChecker, \\"createShapeTypeChecker\\");
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== \\"object\\") {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \`\\" + propType + \\"\` \\" + (\\"supplied to \`\\" + componentName + \\"\`, expected \`object\`.\\"));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== \\"function\\") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                \\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` key \`\\" + key + \\"\` supplied to \`\\" + componentName + \\"\`.\\
Bad object: \\" + JSON.stringify(props[propName], null, \\"  \\") + \\"\\
Valid keys: \\" + JSON.stringify(Object.keys(shapeTypes), null, \\"  \\")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + \\".\\" + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createStrictShapeTypeChecker, \\"createStrictShapeTypeChecker\\");
      function isNode(propValue) {
        switch (typeof propValue) {
          case \\"number\\":
          case \\"string\\":
          case \\"undefined\\":
            return true;
          case \\"boolean\\":
            return !propValue;
          case \\"object\\":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      __name(isNode, \\"isNode\\");
      function isSymbol(propType, propValue) {
        if (propType === \\"symbol\\") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue[\\"@@toStringTag\\"] === \\"Symbol\\") {
          return true;
        }
        if (typeof Symbol === \\"function\\" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      __name(isSymbol, \\"isSymbol\\");
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return \\"array\\";
        }
        if (propValue instanceof RegExp) {
          return \\"object\\";
        }
        if (isSymbol(propType, propValue)) {
          return \\"symbol\\";
        }
        return propType;
      }
      __name(getPropType, \\"getPropType\\");
      function getPreciseType(propValue) {
        if (typeof propValue === \\"undefined\\" || propValue === null) {
          return \\"\\" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === \\"object\\") {
          if (propValue instanceof Date) {
            return \\"date\\";
          } else if (propValue instanceof RegExp) {
            return \\"regexp\\";
          }
        }
        return propType;
      }
      __name(getPreciseType, \\"getPreciseType\\");
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case \\"array\\":
          case \\"object\\":
            return \\"an \\" + type;
          case \\"boolean\\":
          case \\"date\\":
          case \\"regexp\\":
            return \\"a \\" + type;
          default:
            return type;
        }
      }
      __name(getPostfixForTypeWarning, \\"getPostfixForTypeWarning\\");
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      __name(getClassName, \\"getClassName\\");
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js\\"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// ../external/three/src/prop_types.js
var import_bundle_all_prop_types = __toESM(require_prop_types());
var prop_types_default = /* @__PURE__ */ __name(() => {
  import_bundle_all_prop_types.default;
}, \\"default\\");
export {
  prop_types_default as default
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=/npm:@external/three/src/prop_types.map
"
`;

snapshot[`import map > should use root as resolveDir when using bundle-all: prefix 1`] = `
"var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, \\"name\\", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === \\"object\\" || typeof from === \\"function\\") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. \\"__esModule\\" has not been set), then set
  // \\"default\\" to the CommonJS \\"module.exports\\" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \\"default\\", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, \\"__esModule\\", { value: true }), mod);

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/cjs/react-is.development.js\\"(exports) {
    \\"use strict\\";
    if (true) {
      (function() {
        \\"use strict\\";
        var hasSymbol = typeof Symbol === \\"function\\" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\\"react.element\\") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\\"react.portal\\") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\\"react.fragment\\") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\\"react.strict_mode\\") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\\"react.profiler\\") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\\"react.provider\\") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\\"react.context\\") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\\"react.async_mode\\") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\\"react.concurrent_mode\\") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\\"react.forward_ref\\") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\\"react.suspense\\") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\\"react.suspense_list\\") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\\"react.memo\\") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\\"react.lazy\\") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\\"react.block\\") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\\"react.fundamental\\") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\\"react.responder\\") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\\"react.scope\\") : 60119;
        function isValidElementType(type) {
          return typeof type === \\"string\\" || typeof type === \\"function\\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \\"object\\" && type !== null && (type.\$\$typeof === REACT_LAZY_TYPE || type.\$\$typeof === REACT_MEMO_TYPE || type.\$\$typeof === REACT_PROVIDER_TYPE || type.\$\$typeof === REACT_CONTEXT_TYPE || type.\$\$typeof === REACT_FORWARD_REF_TYPE || type.\$\$typeof === REACT_FUNDAMENTAL_TYPE || type.\$\$typeof === REACT_RESPONDER_TYPE || type.\$\$typeof === REACT_SCOPE_TYPE || type.\$\$typeof === REACT_BLOCK_TYPE);
        }
        __name(isValidElementType, \\"isValidElementType\\");
        function typeOf(object) {
          if (typeof object === \\"object\\" && object !== null) {
            var \$\$typeof = object.\$\$typeof;
            switch (\$\$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var \$\$typeofType = type && type.\$\$typeof;
                    switch (\$\$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return \$\$typeofType;
                      default:
                        return \$\$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return \$\$typeof;
            }
          }
          return void 0;
        }
        __name(typeOf, \\"typeOf\\");
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console[\\"warn\\"](\\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\\");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        __name(isAsyncMode, \\"isAsyncMode\\");
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        __name(isConcurrentMode, \\"isConcurrentMode\\");
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        __name(isContextConsumer, \\"isContextConsumer\\");
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        __name(isContextProvider, \\"isContextProvider\\");
        function isElement(object) {
          return typeof object === \\"object\\" && object !== null && object.\$\$typeof === REACT_ELEMENT_TYPE;
        }
        __name(isElement, \\"isElement\\");
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        __name(isForwardRef, \\"isForwardRef\\");
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        __name(isFragment, \\"isFragment\\");
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        __name(isLazy, \\"isLazy\\");
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        __name(isMemo, \\"isMemo\\");
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        __name(isPortal, \\"isPortal\\");
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        __name(isProfiler, \\"isProfiler\\");
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        __name(isStrictMode, \\"isStrictMode\\");
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        __name(isSuspense, \\"isSuspense\\");
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js
var require_react_is = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/react-is@16.13.1/node_modules/react-is/index.js\\"(exports, module) {
    \\"use strict\\";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/src/object_assign.js
var object_assign_exports = {};
__export(object_assign_exports, {
  default: () => object_assign_default
});
var object_assign_default;
var init_object_assign = __esm({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/src/object_assign.js\\"() {
    object_assign_default = Object.assign;
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js\\"(exports, module) {
    \\"use strict\\";
    var ReactPropTypesSecret = \\"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\\";
    module.exports = ReactPropTypesSecret;
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/has.js\\"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/checkPropTypes.js\\"(exports, module) {
    \\"use strict\\";
    var printWarning = /* @__PURE__ */ __name(function() {
    }, \\"printWarning\\");
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = /* @__PURE__ */ __name(function(text) {
        var message = \\"Warning: \\" + text;
        if (typeof console !== \\"undefined\\") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      }, \\"printWarning\\");
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== \\"function\\") {
                var err = Error(
                  (componentName || \\"React class\\") + \\": \\" + location + \\" type \`\\" + typeSpecName + \\"\` is invalid; it must be a function, usually from the \`prop-types\` package, but received \`\\" + typeof typeSpecs[typeSpecName] + \\"\`.This often happens because of typos such as \`PropTypes.function\` instead of \`PropTypes.func\`.\\"
                );
                err.name = \\"Invariant Violation\\";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || \\"React class\\") + \\": type specification of \\" + location + \\" \`\\" + typeSpecName + \\"\` is invalid; the type checker function must return \`null\` or an \`Error\` but returned a \\" + typeof error + \\". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\\"
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : \\"\\";
              printWarning(
                \\"Failed \\" + location + \\" type: \\" + error.message + (stack != null ? stack : \\"\\")
              );
            }
          }
        }
      }
    }
    __name(checkPropTypes, \\"checkPropTypes\\");
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithTypeCheckers.js\\"(exports, module) {
    \\"use strict\\";
    var ReactIs = require_react_is();
    var assign = (init_object_assign(), __toCommonJS(object_assign_exports));
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = /* @__PURE__ */ __name(function() {
    }, \\"printWarning\\");
    if (true) {
      printWarning = /* @__PURE__ */ __name(function(text) {
        var message = \\"Warning: \\" + text;
        if (typeof console !== \\"undefined\\") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      }, \\"printWarning\\");
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    __name(emptyFunctionThatReturnsNull, \\"emptyFunctionThatReturnsNull\\");
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === \\"function\\" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = \\"@@iterator\\";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === \\"function\\") {
          return iteratorFn;
        }
      }
      __name(getIteratorFn, \\"getIteratorFn\\");
      var ANONYMOUS = \\"<<anonymous>>\\";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker(\\"array\\"),
        bigint: createPrimitiveTypeChecker(\\"bigint\\"),
        bool: createPrimitiveTypeChecker(\\"boolean\\"),
        func: createPrimitiveTypeChecker(\\"function\\"),
        number: createPrimitiveTypeChecker(\\"number\\"),
        object: createPrimitiveTypeChecker(\\"object\\"),
        string: createPrimitiveTypeChecker(\\"string\\"),
        symbol: createPrimitiveTypeChecker(\\"symbol\\"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      __name(is, \\"is\\");
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === \\"object\\" ? data : {};
        this.stack = \\"\\";
      }
      __name(PropTypeError, \\"PropTypeError\\");
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                \\"Calling PropTypes validators directly is not supported by the \`prop-types\` package. Use \`PropTypes.checkPropTypes()\` to call them. Read more at http://fb.me/use-check-prop-types\\"
              );
              err.name = \\"Invariant Violation\\";
              throw err;
            } else if (typeof console !== \\"undefined\\") {
              var cacheKey = componentName + \\":\\" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  \\"You are manually calling a React.PropTypes validation function for the \`\\" + propFullName + \\"\` prop on \`\\" + componentName + \\"\`. This is deprecated and will throw in the standalone \`prop-types\` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\\"
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError(\\"The \\" + location + \\" \`\\" + propFullName + \\"\` is marked as required \\" + (\\"in \`\\" + componentName + \\"\`, but its value is \`null\`.\\"));
              }
              return new PropTypeError(\\"The \\" + location + \\" \`\\" + propFullName + \\"\` is marked as required in \\" + (\\"\`\\" + componentName + \\"\`, but its value is \`undefined\`.\\"));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        __name(checkType, \\"checkType\\");
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      __name(createChainableTypeChecker, \\"createChainableTypeChecker\\");
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              \\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + preciseType + \\"\` supplied to \`\\" + componentName + \\"\`, expected \\") + (\\"\`\\" + expectedType + \\"\`.\\"),
              { expectedType }
            );
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createPrimitiveTypeChecker, \\"createPrimitiveTypeChecker\\");
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      __name(createAnyTypeChecker, \\"createAnyTypeChecker\\");
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== \\"function\\") {
            return new PropTypeError(\\"Property \`\\" + propFullName + \\"\` of component \`\\" + componentName + \\"\` has invalid PropType notation inside arrayOf.\\");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected an array.\\"));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + \\"[\\" + i + \\"]\\", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createArrayOfTypeChecker, \\"createArrayOfTypeChecker\\");
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected a single ReactElement.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createElementTypeChecker, \\"createElementTypeChecker\\");
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected a single ReactElement type.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createElementTypeTypeChecker, \\"createElementTypeTypeChecker\\");
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + actualClassName + \\"\` supplied to \`\\" + componentName + \\"\`, expected \\") + (\\"instance of \`\\" + expectedClassName + \\"\`.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createInstanceTypeChecker, \\"createInstanceTypeChecker\\");
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                \\"Invalid arguments supplied to oneOf, expected an array, got \\" + arguments.length + \\" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\\"
              );
            } else {
              printWarning(\\"Invalid argument supplied to oneOf, expected an array.\\");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, /* @__PURE__ */ __name(function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === \\"symbol\\") {
              return String(value);
            }
            return value;
          }, \\"replacer\\"));
          return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of value \`\\" + String(propValue) + \\"\` \\" + (\\"supplied to \`\\" + componentName + \\"\`, expected one of \\" + valuesString + \\".\\"));
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createEnumTypeChecker, \\"createEnumTypeChecker\\");
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== \\"function\\") {
            return new PropTypeError(\\"Property \`\\" + propFullName + \\"\` of component \`\\" + componentName + \\"\` has invalid PropType notation inside objectOf.\\");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== \\"object\\") {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \\" + (\\"\`\\" + propType + \\"\` supplied to \`\\" + componentName + \\"\`, expected an object.\\"));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + \\".\\" + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createObjectOfTypeChecker, \\"createObjectOfTypeChecker\\");
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning(\\"Invalid argument supplied to oneOfType, expected an instance of array.\\") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== \\"function\\") {
            printWarning(
              \\"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \\" + getPostfixForTypeWarning(checker) + \\" at index \\" + i + \\".\\"
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, \\"expectedType\\")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? \\", expected one of type [\\" + expectedTypes.join(\\", \\") + \\"]\\" : \\"\\";
          return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` supplied to \\" + (\\"\`\\" + componentName + \\"\`\\" + expectedTypesMessage + \\".\\"));
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createUnionTypeChecker, \\"createUnionTypeChecker\\");
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` supplied to \\" + (\\"\`\\" + componentName + \\"\`, expected a ReactNode.\\"));
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createNodeChecker, \\"createNodeChecker\\");
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || \\"React class\\") + \\": \\" + location + \\" type \`\\" + propFullName + \\".\\" + key + \\"\` is invalid; it must be a function, usually from the \`prop-types\` package, but received \`\\" + type + \\"\`.\\"
        );
      }
      __name(invalidValidatorError, \\"invalidValidatorError\\");
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== \\"object\\") {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \`\\" + propType + \\"\` \\" + (\\"supplied to \`\\" + componentName + \\"\`, expected \`object\`.\\"));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== \\"function\\") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + \\".\\" + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createShapeTypeChecker, \\"createShapeTypeChecker\\");
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== \\"object\\") {
            return new PropTypeError(\\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` of type \`\\" + propType + \\"\` \\" + (\\"supplied to \`\\" + componentName + \\"\`, expected \`object\`.\\"));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== \\"function\\") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                \\"Invalid \\" + location + \\" \`\\" + propFullName + \\"\` key \`\\" + key + \\"\` supplied to \`\\" + componentName + \\"\`.\\
Bad object: \\" + JSON.stringify(props[propName], null, \\"  \\") + \\"\\
Valid keys: \\" + JSON.stringify(Object.keys(shapeTypes), null, \\"  \\")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + \\".\\" + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        __name(validate, \\"validate\\");
        return createChainableTypeChecker(validate);
      }
      __name(createStrictShapeTypeChecker, \\"createStrictShapeTypeChecker\\");
      function isNode(propValue) {
        switch (typeof propValue) {
          case \\"number\\":
          case \\"string\\":
          case \\"undefined\\":
            return true;
          case \\"boolean\\":
            return !propValue;
          case \\"object\\":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      __name(isNode, \\"isNode\\");
      function isSymbol(propType, propValue) {
        if (propType === \\"symbol\\") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue[\\"@@toStringTag\\"] === \\"Symbol\\") {
          return true;
        }
        if (typeof Symbol === \\"function\\" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      __name(isSymbol, \\"isSymbol\\");
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return \\"array\\";
        }
        if (propValue instanceof RegExp) {
          return \\"object\\";
        }
        if (isSymbol(propType, propValue)) {
          return \\"symbol\\";
        }
        return propType;
      }
      __name(getPropType, \\"getPropType\\");
      function getPreciseType(propValue) {
        if (typeof propValue === \\"undefined\\" || propValue === null) {
          return \\"\\" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === \\"object\\") {
          if (propValue instanceof Date) {
            return \\"date\\";
          } else if (propValue instanceof RegExp) {
            return \\"regexp\\";
          }
        }
        return propType;
      }
      __name(getPreciseType, \\"getPreciseType\\");
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case \\"array\\":
          case \\"object\\":
            return \\"an \\" + type;
          case \\"boolean\\":
          case \\"date\\":
          case \\"regexp\\":
            return \\"a \\" + type;
          default:
            return type;
        }
      }
      __name(getPostfixForTypeWarning, \\"getPostfixForTypeWarning\\");
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      __name(getClassName, \\"getClassName\\");
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  \\"bundleAll:/Users/joelmoss/dev/proscenium/test/external/three/node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js\\"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// ../external/three/src/prop_types.js
var import_bundle_all_prop_types = __toESM(require_prop_types());
var prop_types_default = /* @__PURE__ */ __name(() => {
  import_bundle_all_prop_types.default;
}, \\"default\\");
export {
  prop_types_default as default
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=/npm:@external/three/src/prop_types.map
"
`;
